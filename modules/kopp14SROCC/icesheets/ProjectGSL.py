import numpy as np

''' ProjectGSL.py

This function produces global sea-level rise projections after sampling the fitted
ice sheet distributions. Projections are made by convoluting both the BA and AR
estimates.

Parameters: 
baaccelsamps = BA samples generated by SampleISDists
araccelsamps = AR samples generated by SampleISDists
islastdecade = Ice sheet accelerations(?) for the last decade
targyears = Years to produce a global sea-level rise projection

Return: An array of dimensions [nsamps, len(targyears), 3] of samples of sea-level rise
contributions due to ice sheets.

Note: 'nsamps' is the number of samples used in the SampleISDists function call and is
determined by the length of the sample dimension of 'baaccelsamps' and 'araccelsamps' 
respectively.

'''

def ProjectGSL(baaccelsamps, araccelsamps, islastdecade, targyears):
	
	# Reshape the 'targyears' for easier calculations
	targyears = targyears.reshape(-1,1)
	
	# Calculate the contribution as estimated in BA
	def proj_over_samp(samp, targyears, islastdecade):
		return((islastdecade * (targyears - 2005)) + (0.5 * samp * (targyears - 2011)**2 * (targyears > 2011)))
	def add_last_two(x):
		return(x[-1] + x[-2])
		
	basamps = np.apply_along_axis(proj_over_samp, 1, baaccelsamps, targyears=targyears, islastdecade=islastdecade)
	arsamps = np.apply_along_axis(proj_over_samp, 1, araccelsamps, targyears=targyears, islastdecade=np.array([islastdecade[0], islastdecade[1]+islastdecade[2]]))
	
	# Append the total AIS contribution to the end of 'basamps' as is done in the 
	# original code.
	basamps = np.concatenate((basamps, np.apply_along_axis(add_last_two, 2, basamps)[:,:,None]), 2)
	
	# Calculate the quantiles
	def qfun(x, q):
		return(np.quantile(x, q))
		
	baq = np.apply_along_axis(qfun, 0, basamps, q=np.array([0.167, 0.5, 0.833]))
	arq = np.apply_along_axis(qfun, 0, arsamps, q=np.array([0.167, 0.5, 0.833]))
	
	# Find the slopes of the quantiles
	baq_diff = np.apply_along_axis(np.diff, 0, baq)
	arq_diff = np.apply_along_axis(np.diff, 0, arq)
	qslopes = arq_diff / (baq_diff[:,:,[0,3]] + np.finfo(float).eps)
	
	# Convolute the AR and BA samples 
	hysamps = basamps[:,:,[0,3]] - baq[1,:,[0,3]].T
	hysamps_left = (hysamps < 0) * (hysamps * qslopes[0,:,:])
	hysamps_right = (hysamps > 0) * (hysamps * qslopes[1,:,:])
	hysamps = hysamps_left + hysamps_right + arq[1,:,:]
	
	# Determine the WAIS hybrid contributions
	hysamps_wais = basamps[:,:,1] - baq[1,:,1]
	hysamps_wais_left = (hysamps_wais < 0) * (hysamps_wais * qslopes[0,:,1])
	hysamps_wais_right = (hysamps_wais > 0) * (hysamps_wais * qslopes[1,:,1])
	hysamps_wais = hysamps_wais_left + hysamps_wais_right + baq[1,:,1] * arq[1,:,1] / baq[1,:,3]
	hysamps_wais = np.minimum(hysamps_wais, 5000)
	
	# Determine the EAIS hybrid contributions
	hysamps_eais = hysamps[:,:,1] - hysamps_wais
	
	# Reassemble all the hybrid samples into a single matrix
	hysamps = np.stack((hysamps[:,:,0], hysamps_wais, hysamps_eais), -1)
	
	# Apply constraint
	# Note: Not sure why we're reapplying the constraint for WAIS and nothing for EAIS...
	hysamps[:,:,0] = np.minimum(hysamps[:,:,0], 7000)
	hysamps[:,:,1] = np.minimum(hysamps[:,:,1], 5000)
	
	# Use the WAIS hybrid values to fill out AR estimates
	arsamps = np.stack((arsamps[:,:,0], hysamps_wais, arsamps[:,:,1]-hysamps_wais), 2)
	
	# Return the AR, BA, and Hybrid projections
	return(arsamps, basamps[:,:,[0,1,2]], hysamps)